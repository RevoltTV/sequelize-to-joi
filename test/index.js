import { expect } from 'chai';
import Sequelize  from 'sequelize';
import Joi        from '@hapi/joi';

import sequelizeToJoi from '../src';

describe('sequelize-to-joi', () => {
    let sequelize;

    before(() => {
        sequelize = new Sequelize('test', '', null, { dialect: 'sqlite' });

        let Basic = sequelize.define('Basic', {
            name: Sequelize.STRING,
            email: {
                type: Sequelize.STRING,
                allowNull: false,
                validate: {
                    isEmail: true
                }
            },
            count: Sequelize.INTEGER,
            date: {
                type: Sequelize.DATE
            }
        });

        let References = sequelize.define('Reference', {
            total: Sequelize.INTEGER
        });

        sequelize.define('User', {
            name: Sequelize.STRING,
            cash: Sequelize.FLOAT(2,4),
            settings: {
                type: Sequelize.JSONB,
                sequelizeToJoiOverride: Joi.object({
                    flag: Joi.string().valid('white','red','blue'),
                }),
            },
        });

        let Geo = sequelize.define('Geo', {
            geojson: Sequelize.GEOMETRY,
        });

        References.belongsTo(Basic);
        Geo.belongsTo(Basic);
    });

    it('should exist and be a function', () => {
        expect(sequelizeToJoi).to.exist.and.be.a('function');
    });

    it('should throw TypeError if model is not instance of Sequelize Model', () => {
        expect(sequelizeToJoi).to.throw(TypeError);
    });

    it('should validate Basic model', () => {
        let schema = sequelizeToJoi(sequelize.models.Basic);
        let test = {
            id: 1,
            name: 'test',
            email: 'a@b.co',
            count: 10,
            date: (new Date()).toISOString(),
            createdAt: (new Date()).toISOString(),
            updatedAt: (new Date()).toISOString()
        };

        let result1 = Joi.validate(test, schema);
        expect(result1.error).to.not.exist;
        expect(result1.value).to.contain.all.keys(test);

        test.email = 'invalid';
        let result2 = Joi.validate(test, schema);
        expect(result2.error).to.exist;
        expect(result2.error.message).to.contain('email');
    });

    it('should test custom joi validator and floats', () => {
        let schema = sequelizeToJoi(sequelize.models.User, { omitAutoGenerated: true });
        let test = {
            name: 'test',
            cash: 99.95,
            settings: {
                flag: 'white',
            },
        };

        let result = Joi.validate(test, schema);
        expect(result.error).to.not.exist;
        expect(result.value).to.contain.all.keys(test);

        test.settings.flag = 'invalid';
        result = Joi.validate(test, schema);
        expect(result.error).to.exist;
        expect(result.error.message).to.contain('settings');

        //test length infront of decimal validator
        test.cash = 2292.2342354;
        test.settings.flag = 'blue';
        result = Joi.validate(test, schema);
        expect(result.error).to.exist;
        expect(result.error.message).to.contain('cash');

        //test decimal precision validator
        test.cash = 92.21231324;
        result = Joi.validate(test, schema);
        expect(result.error).to.exist;
        expect(result.error.message).to.contain('cash');

    });

    it('should allow omitting auto generated properties', () => {
        // id, createdAt, updatedAt are autogenerated (and required)
        // this should omit them from validation
        let schema = sequelizeToJoi(sequelize.models.Basic, { omitAutoGenerated: true });

        let test = {
            name: 'test',
            email: 'a@b.co',
            count: 10,
            date: new Date()
        };

        let result = Joi.validate(test, schema);
        expect(result.error).to.not.exist;
        expect(result.value).to.deep.equal(test);
    });

    it('should handle referenced models', () => {
        let schema = sequelizeToJoi(sequelize.models.Reference);

        let test = {
            id: 2,
            total: 10,
            BasicId: 1,
            Basic: {
                id: 1,
                name: 'valid',
                email: 'a@b.co',
                count: 5,
                date: (new Date()).toISOString(),
                createdAt: (new Date()).toISOString(),
                updatedAt: (new Date()).toISOString()
            },
            createdAt: (new Date()).toISOString(),
            updatedAt: (new Date()).toISOString()
        };

        let result = Joi.validate(test, schema);
        expect(result.error).to.not.exist;
        expect(result.value).to.deep.contain.all.keys(test);
    });

    it('should allow null values when allowNull is not specified', () => {
        let schema = sequelizeToJoi(sequelize.models.Basic, { omitAutoGenerated: true });
        let test = {
            name: 'test',
            email: 'a@b.co',
            count: 10,
            date: null
        };

        let result = Joi.validate(test, schema);
        expect(result.error).to.not.exist;
        expect(result.value).to.deep.contain.all.keys(test);
        expect(result.value).to.deep.equal(test);
    });

    it('should pass proper geojson object', () => {
        let schema = sequelizeToJoi(sequelize.models.Geo, { omitAutoGenerated: true });
        let test = {
            geojson : {
                type: "FeatureCollection",
                features: [{ 
                    "type": "Feature",
                    "geometry": {"type": "Point", "coordinates": [102.0, 0.5]},
                    "properties": {"prop0": "value0"}
                }, { 
                    "type": "Feature",
                    "geometry": {
                        "type": "Linestring",
                        "coordinates": [100.0, 1.0],

                    },
                    "properties": {
                        "prop0": "value0",
                        "prop1": 0.0
                    }
                }, { 
                    "type": "Feature",
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [
                            [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
                            [100.0, 1.0], [100.0, 0.0] ]
                        ]
                    },
                    "properties": {
                        "prop0": "value0",
                        "prop1": {"this": "that"}
                    }
                }]
            }
        };

        let result = Joi.validate(test, schema);
        expect(result.error).to.not.exist;
        expect(result.value).to.deep.contain.all.keys(test);
        expect(result.value).to.deep.equal(test);
    });

    it('should fail improper geojson object', () => {
        let schema = sequelizeToJoi(sequelize.models.Geo, { omitAutoGenerated: true });
        let test = {
            geojson : {
                type: "FeatureCollection",
                features: [{ 
                    "type": "Feature",
                    "geometry": {"type": "Point", "coordinates": [102.0, 0.5]},
                    "properties": {"prop0": "value0"}
                }, { 
                    "type": "Feature",
                    "geometry": {
                        "type": "Linestring",
                        //coordinates should be an array
                        "coordinates": 1,

                    },
                    "properties": {
                        "prop0": "value0",
                        "prop1": 0.0
                    }
                }, { 
                    "type": "Feature",
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [
                            [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
                            [100.0, 1.0], [100.0, 0.0] ]
                        ]
                    },
                    "properties": {
                        "prop0": "value0",
                        "prop1": {"this": "that"}
                    }
                }]
            }
        };

        let result = Joi.validate(test, schema);
        expect(result.error).to.exist;
        expect(result.error.message).to.contain('coordinates');
    });
});
